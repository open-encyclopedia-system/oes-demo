<?php

namespace OES\Theme;

use Mpdf\Mpdf;
use Mpdf\MpdfException;
use OES\Versioning as V;
use OES\Config as C;
use function OES\ACF\get_acf_field;
use function OES\ACF\get_all_post_type_fields;
use function OES\ACF\get_field_value_for_display;


if (!defined('ABSPATH')) exit; // Exit if accessed directly

if (!class_exists('OES_Post_Type_Theme')) {

    /**
     * Class OES_Post_Type_Theme
     *
     * This class prepares a post type for display in the frontend theme.
     */
    class OES_Post_Type_Theme
    {

        /** @var int $postID An int containing the post id. */
        var $postID;

        /** @var string $postType A string containing the post type. */
        var $postType;

        /** @var int $masterID An int containing the master post id connected to the post id. */
        var $masterID;

        /** @var int $translationID An int containing the translated post id connected to the post id. */
        var $translationIDs = [];

        /** @var string $title A string containing the post title. */
        var $title;

        /** @var array $fields An array containing the post fields. */
        var $fields;

        /** @var array $fields An array containing the post field keys that are generated by customized setting of
         * fields. This is needed for comparing set fields to generated fields.
         */
        var $overwrittenFieldKeys;

        /** @var array $tableOfContent An array containing the table of content header. */
        var $tableOfContent;

        /** @var string $tableOfContentJumpIcon A string containing the icon to jump back to table of content. */
        protected $tableOfContentJumpIcon;

        /** @var array $archiveData An array containing the data which is displayed in the archive. */
        var $archiveData;

        /** @var boolean $pdf A boolean indicating if output is generated for a pdf. Default is false. */
        var $pdf = false;


        /**
         * OES_Post_Type_Theme constructor.
         *
         * @param int|boolean $postID An integer containing the post id. If empty, take the current post.
         * @param array|null $additionalParameters An array containing additional parameters.
         */
        public function __construct($postID = false, $additionalParameters = null)
        {
            /* Add class variables */
            $this->add_class_variables($additionalParameters);

            /* Set post id */
            if ($postID) $this->set_post_id($postID);
            else $this->set_post_id(get_the_ID());

            /* Set post type */
            $this->postType = get_post_type($this->postID);

            /* Set master post id if master post exists. */
            $this->masterID = V\get_master_id($this->postID);

            /* Set translation post id if exists. */
            $this->set_translation_ids();

            /* Set title for post. */
            $this->set_title();

            /* Set fields */
            $this->set_fields(false);

            /* Set data */
            $this->set_data();

            /* Set table of content icon to jump back to table of content */
            $this->set_table_of_content_jump_icon();
        }


        /**
         * Add additional class variables
         *
         * TODO @2.0 Roadmap : specify class, see OES Demo Theme, post type 'Index'
         * @param array $additionalParameters Array or List? of additional parameters
         */
        function add_class_variables($additionalParameters)
        {

        }


        /**
         * Set post id for post.
         *
         * @param int $postID An integer containing the post id. If post with id does not exist, take current post.
         */
        function set_post_id($postID)
        {
            $this->postID = (false === get_post_status($postID)) ? get_the_ID() : $postID;
        }


        /**
         * Set translation IDs for post connecting the post to its origin or translated version.
         * Stores the post language.
         */
        function set_translation_ids()
        {
            $postOriginVersionID = V\get_origin_version_id($this->postID);
            $postTranslatedVersionID = V\get_translated_version_id($this->postID);
            if ($postOriginVersionID) {
                $this->translationIDs[$postOriginVersionID] = V\get_language_string($this->postType, 'primary');
            }
            if ($postTranslatedVersionID) {
                $this->translationIDs[$postTranslatedVersionID] = V\get_language_string($this->postType, 'secondary');
            }
        }


        /**
         * Get title of post.
         *
         * @return String Returns String containing the post title.
         */
        function get_title()
        {
            return $this->title;
        }


        /**
         * Set post title.
         */
        function set_title()
        {
            $this->title = oes_get_display_title($this->postID);
        }


        /**
         * Set icon to jump back to table of content.
         */
        function set_table_of_content_jump_icon()
        {
        }


        /**
         * Set fields for post, containing field information.
         *
         * @param bool $overwrite TODO @2.0 Roadmap : check if fields should be overwritten from backend configurations.
         * Currently this means that theme class overwrites configuration in backend!
         */
        function set_fields($overwrite = false)
        {

            /* get all fields for post type */
            $allFields = get_all_post_type_fields($this->postType, false);

            /* loop through all fields */
            foreach ($allFields as $singleFieldKey => $singleField) {

                /* skip field if already set */
                if ((!empty($this->overwrittenFieldKeys) &&
                    ($this->fields[$singleFieldKey] || in_array($singleFieldKey, $this->overwrittenFieldKeys)))
                    && !$overwrite) continue;

                /* set field */
                $this->set_single_field($singleFieldKey);
            }
        }


        /**
         * Set single field for post, containing field information.
         *
         * @param string $key An integer containing the field key.
         * @param array $args An array containing additional information. Valid parameters are:
         *  'indicator'  A string containing the field indicator (to shorten call etc TODO @2.0 Roadmap : add documentation)
         *  'label'      A string containing the field label if different from acf field label or the configuration
         *               inside the admin panel.
         *  'meta'       A boolean indicating if field is meta data field.
         *  'archive'    A boolean indication if field is displayed in archive.
         *  'master'     A boolean indicating if the field value is stored in the master post.
         *  'link'       A boolean indicating if the field value is displayed as link.
         *  'custom'     A parameter containing custom parameters.
         */
        function set_single_field($key, $args = null)
        {
            /* get all option parameters for post type */
            $themeOptions = get_option(C\Option::THEME . '-' . $this->postType);

            /* Set key as field indicator if field indicator is missing*/
            if (!$args['indicator']) $fieldIndicator = $key;

            /* Set key as label if label is missing */
            if (!$args['label']) {
                if (isset($themeOptions[$key . '-label_for_frontend']) &&
                    !empty($themeOptions[$key . '-label_for_frontend'])) {
                    $label = $themeOptions[$key . '-label_for_frontend'];
                } else $label = get_field_object($key, $this->postID)['label'];
            }

            /* check if meta is set in configuration panel */
            if (!isset($args['meta'])) {
                if (isset($themeOptions[$key . '-include_in_meta'])) $meta = true;
                else $meta = false;
            } else $meta = $args['meta'];

            /* check if archive is set in configuration panel */
            if (!isset($args['archive'])) {
                if ($themeOptions[$key . '-include_in_archive']) $archive = true;
            } else $archive = $args['archive'];


            if ($args) {
                $master = isset($args['master']) ? $args['master'] : false;
                $custom = isset($args['custom']) ? $args['custom'] : null;
                $link = isset($args['link']) ? $args['link'] : false;
            } else {
                $master = false;
                $custom = null;
                $link = false;
            }

            $this->fields[$fieldIndicator] = [
                'key' => $key,
                'label' => $label,
                'type' => get_field_object($key, $this->postID)['type'],
                'meta' => $meta,
                'archive' => $archive,
                'master' => $master,
                'custom' => $custom,
                'link' => $link,
            ];

            /* set overwritten field keys collector */
            $this->overwrittenFieldKeys[$key] = $key;

        }


        /**
         * Check if field value is not empty.
         *
         * @param $fieldKey String containing the field key.
         * @return bool Return if the field value is empty or not.
         */
        function check_if_field_not_empty($fieldKey)
        {
            return (isset($this->fields[$fieldKey]['value']) && !empty($this->fields[$fieldKey]['value']));
        }


        /**
         * Check if post should be excluded from list view.
         */
        function check_if_post_is_hidden(){}


        /**
         * Set field data by retrieving field value.
         */
        function set_data()
        {
            /* loop through all fields */
            foreach ($this->fields as $thisKey => $field) {

                /* check if there exists a master article from which to take the field value */
                $postIDForField = $field['master'] ? ($this->masterID ? $this->masterID : $this->postID) : $this->postID;

                /* get value to be displayed */
                $valueForDisplay = get_field_value_for_display($field['key'],
                    $postIDForField,
                    ['value-is-link' => $field['link'], 'list-id' => 'value-list-id']);
                $this->fields[$thisKey] = array_merge($this->fields[$thisKey], $valueForDisplay);

                /* collect archive data */
                $archiveValue = $field['archive'] ? $valueForDisplay['value-display'] : '';
                if ($field['archive'] && $archiveValue) $this->add_archive_data($archiveValue, $field['label']);
            }
        }


        /**
         * Get archive data for this post. Archive data should have the syntax ['label', 'value'].
         */
        function get_archive_data()
        {
            return $this->archiveData;
        }


        /**
         * Add data to archive data (data which will be displayed in archive pages).
         *
         * @param string $value A string containing the value which is to be added to archive data.
         * @param string $label Optional string containing the label for the value.
         * @param bool $key An optional boolean indicating if key should be incremented. Default is false.
         */
        function add_archive_data($value, $label = '', $key = false)
        {
            /* check if key already exists */
            $archiveDataKey = $key;

            if (empty($this->archiveData)) {
                $archiveDataKey = 10;
            } else {
                if (!$archiveDataKey) $archiveDataKey = 10;
                while ($this->archiveData[$archiveDataKey]) {
                    if ($key) $archiveDataKey += 10; /* increment by 10 if default key */
                    else ++$archiveDataKey;
                }
            }

            $this->archiveData[$archiveDataKey] = ['label' => $label, 'value' => $value];
        }


        /**
         * Generate a table of content header. Return the title with an anchor indicating the header level.
         *
         * @param string $headerText A string containing the header text.
         * @param int $level An integer containing the level. Default is 1.
         * @param false $id An integer containing the anchor id. Default ist a composition of $headerText and $level.
         * @param string $headerClass A string containing the css class for the header class.
         * Default is 'content-table-header'.
         *
         * @return string Returns a string containing header text, header class an anchor for display.
         */
        function generate_table_of_content_header($headerText, $level = 1, $id = false, $headerClass = 'content-table-header')
        {
            /* strip tags */
            $headerText = strip_tags($headerText);

            /* prepare anchor by replacing space in title */
            if (!$id) $id = preg_replace('/\s+/', '_', $headerText);
            $id = strtolower($id);

            /* add to table of content */
            $this->tableOfContent[] = ['anchor' => $id, 'label' => $headerText, 'level' => $level];

            /* prepare the jump icon */
            $jumpIcon = $this->tableOfContentJumpIcon ?
                sprintf('<a href="#top" class="toc-anchor"><span>%1$s</span></a>',
                    $this->tableOfContentJumpIcon
                ) :
                '';

            return sprintf('<div class="%1$s%2$s" id="%3$s">%4$s%5$s</div>',
                $headerClass,
                $level,
                $id,
                $headerText,
                $jumpIcon
            );
        }


        /**
         * Replace header text html tags <h1>, ..., <h6> in string with this classes header text while adding header to
         * table of content.
         *
         * @param string $input A string containing the text to be scanned.
         * @param int $maxLevel An integer indicating the maximum header level.
         * @param int $minLevel An integer indicating the minimum header level.
         * @return string Returns a string containing the input text with replaced header texts.
         */
        function replace_header_tags_in_string($input, $maxLevel = 7, $minLevel = 1)
        {

            $inputTemp = $input;

            /* loop through header types <h1>, <h2>, ... */
            for ($i = $minLevel; $i < $maxLevel; $i++) {

                /* get all header inside input */
                $splitInput = explode('<h' . $i . '>', $inputTemp);

                $ignoreFirst = true;
                $replacedInputTemp = '';
                foreach ($splitInput as $occurrence) {

                    /* ignore text before first header tag */
                    if ($ignoreFirst) {
                        $ignoreFirst = false;
                        $replacedInputTemp .= $occurrence;
                    } else {

                        /* get content between tags */
                        $splitOccurrence = explode('</h' . $i . '>', $occurrence);

                        /* should be split in two */
                        if (count($splitOccurrence) > 1) {

                            /* add header */
                            $replacedInputTemp .= $this->generate_table_of_content_header($splitOccurrence[0], $i);

                            /* get rid of first entry */
                            array_shift($splitOccurrence);

                            /* add rest */
                            $replacedInputTemp .= implode('', $splitOccurrence);

                        } else {
                            $replacedInputTemp .= $occurrence;
                        }
                    }
                }

                $inputTemp = $replacedInputTemp;
            }

            return $inputTemp;
        }


        /**
         * Main function to display post type.
         *
         * @param array $args An array containing custom parameters.
         * @return string Return the post content as html string.
         */
        function get_html_main($args = [])
        {
            /* prepare data to be displayed after table of content */
            /* This needs to be generated first to include headings for the table of content. */

            /* add content, meta data and topics */
            $dataAfterToC = $this->get_html_content() .
                $this->get_html_meta_data() .
                $this->get_html_topics(false);

            return $this->get_html_table_of_content() . $dataAfterToC;
        }


        /**
         * Get main content of post.
         */
        function get_html_content()
        {
            return get_the_content($this->postID);
        }


        /**
         * Get html representation of footnotes for the frontend.
         *
         * @param string $content A string containing the content including the footnotes.
         * @return string Return the html representation of the footnote list.
         */
        function get_html_footnotes($content, $headerText = false){

            $footNotes = apply_filters('oes_footnote_list', $content);

            if(empty($footNotes)) return '';

            /* Get label from options */
            $footnoteOptions = get_option(C\Option::FOOTNOTES);

            /* Check if section has label. */
            $header = '';
            $label = (isset($footnoteOptions['label'])
                && !empty($footnoteOptions['label'])) ? $footnoteOptions['label'] : 'Footnotes';

            /* overwrite by function call */
            if($headerText) $label = $headerText;

            if (!isset($footnoteOptions['no_header'])) {
                $header = $this->generate_table_of_content_header($label);
            }
            elseif(isset($footnoteOptions['label'])) {
                $header = '<div class="content-table-header1">' . $label . '</div>';
            }

            /* Add filter before label of footnote list. */
            $header = apply_filters('oes_footnote_label', $header, $label);

            return sprintf('<div class="footnotes">%1s%2s</div>',
                $header,
                $footNotes
            );

        }


        /**
         * Display the table of content.
         *
         * @param array $args An array containing parameters for the table of content. Valid parameters are:
         *  'toc-header-exclude'    : A boolean, if false the header above the table of content will be excluded.
         *  'toc-header'            : A string containing the table of content header. Default is 'Table of Content'.
         *  'toc-header-level'      : An integer containing the header level for the table of content header.
         *                            Default is 1.
         *  'toc-header-class'      : A string containing the css header class name. Default is 'content-table-header'.
         *  'wrapper-class'         : A string containing the css div class name. Default is 'table-of-content'.
         *  'ul-wrapper-id'         : A string containing the css ul class name. Default is 'table-of-content'.
         *  'li-wrapper-id'         : A string containing the css li class name. Default is 'header'.
         *
         * @return string Return the table of content as string.
         */
        function get_html_table_of_content($args = [])
        {

            //TODO @2.0 Roadmap : validate $args

            /* table of content header */
            $tocHeader = sprintf('<div class="%1s">%2s</div>',
                ($args['toc-header-class'] ? $args['toc-header-class'] : 'content-table-header') .
                ($args['toc-header-level'] ? $args['toc-header-level'] : 1),
                $args['toc-header'] ? $args['toc-header'] : 'Table of Content'
            );

            /* loop through headings */
            $headingsList = '';
            if (!empty($this->tableOfContent)) {

                if($this->pdf){
                    $headingsList .= '';
                    foreach ($this->tableOfContent as $header) {
                        $headingsList .= sprintf('<a href="#%1s" id="toc_%2s" class="toc-anchor">%3s</a><br>',
                            $header['anchor'],
                            $header['anchor'],
                            $header['label']
                        );
                    }
                }
                else{
                    /* open list */
                    $headingsList .= '<ul id="' .
                        ($args['ul-wrapper-id'] ? $args['ul-wrapper-id'] : 'table-of-content') . '">';

                    foreach ($this->tableOfContent as $header) {
                        $headingsList .= sprintf('<li id="%1s"><a href="#%2s" id="toc_%3s" class="toc-anchor">%4s</a></li>',
                            ($args['li-wrapper-id'] ? $args['li-wrapper-id'] : 'header') . $header['level'],
                            $header['anchor'],
                            $header['anchor'],
                            $header['label']
                        );
                    }

                    /* close list */
                    $headingsList .= '</ul>';
                }
            }

            /* return empty if no headings found */
            if (empty($headingsList)) return '';

            return sprintf('<div class="%1s">%2s%3s</div>',
                ($args['wrapper-class'] ? $args['wrapper-class'] : 'table-of-content'),
                $args['toc-header-exclude'] ? '' : $tocHeader,
                $headingsList
            );
        }


        /**
         * Modify field data before adding it to the html representation of meta data.
         *
         * TODO @2.0 Roadmap : change to filter instead.
         *
         * @param array $field An array containing the field information.
         * @return mixed Returns the modified field information.
         */
        function modify_meta_data($field)
        {
            return $field;
        }


        /**
         * Get html table representation of meta data.
         *
         * TODO @2.0 Roadmap : change to filter instead.
         *
         * @param array $args An array containing table parameter. Valid parameters are:
         *  'displayHeader'  : A string containing the header string. Default is 'Metadata'.
         *  'tableID'        : A string containing the css table id. Default is 'meta-data'.
         *  'headerClass'    : A string containing the css header class. Default is 'content-table-header1'.
         *
         * @return string Return the html table representation of meta data.
         */
        function get_html_meta_data($args = [])
        {
            /* merge args with defaults */
            $args = array_merge([
                'display-header' => 'Metadata',
                'table-id' => 'meta-data',
                'header-class' => 'content-table-header1'
            ],
                $args);

            /* prepare meta data table by looping through all fields and collect meta fields with non empty values */
            $tableDataString = '';
            foreach ($this->fields as $field) {
                if ($field['meta'] && $field['value']) {

                    /* add filter to modify or augment values, alternatively call function.  */
                    $field = apply_filters('oes_get_html_meta_data_field', $field);
                    $field = $this->modify_meta_data($field);

                    if(!$field['skip']){
                        $tableDataString .= sprintf('<tr><th>%1s</th><td>%2s</td></tr>',
                            $field['label'],
                            $field['value-display']
                        );
                    }
                }
            }

            if (empty($tableDataString)) return '';

            return sprintf('<div class="meta-data">%1s<table id="%2s">%3s</table></div>',
                $args['display-header'] ?
                    sprintf('<div class="%1s">%2s</div>', $args['header-class'], $args['display-header']) : '',
                $args['table-id'],
                $tableDataString
            );
        }


        /**
         * Get html table representation of data.
         *
         * @param array $postIDs An array containing post IDs.
         * @param array $args An array containing table parameter. Valid parameters are:
         *  'columns'           : An array containing the column headers. Default value is
         *                        ['permalink' => 'Title', 'type' => 'Type', 'version' => 'Version'].
         *  'sort'              : A string containing the sorting column. Default value is 'title'.
         *  'display-header'    : A string containing the table header. Default value is 'Connected Content'.
         *  'header-class'      : A string containing the css header class. Default value is 'content-table-header1'.
         *  'table-id'          : A string containing the css table id. Default value is empty.
         *
         * @return string Return html table representation of data.
         */
        function get_html_table($postIDs, $args = [])
        {
            /* merge args with defaults */
            $args = array_merge([
                'columns' => ['permalink' => 'Title', 'type' => 'Type', 'version' => 'Version'],
                'sort' => 'title',
                'display-header' => 'Connected Content',
                'header-class' => 'content-table-header1'
            ],
                $args);

            /* get table data */
            $tableData = $this->get_prepared_table($postIDs, $args);

            /* prepare table content string */
            $tableContent = '';
            foreach ($tableData as $row) $tableContent .= '<tr><td>' . implode('</td><td>', $row) . '</td></tr>';

            return sprintf('%1s<table%2s>%3s%4s</table>',
                $args['display-header'] ?
                    sprintf('<div class="%1s">%2s</div>', $args['header-class'], $args['display-header']) : '',
                $args['table-id'] ? ' id="' . $args['table-id'] . '"' : '',
                '<tr><th>' . implode('</th><th>', $args['columns']) . '</th></tr>',
                $tableContent);
        }


        /**
         * Prepare table representation of data.
         *
         * @param array $posts An array containing posts.
         * @param array $args An array containing table parameter. Valid parameters are:
         *  'columns'           : An array containing the column headers. Default value is
         *                        ['permalink' => 'Title', 'type' => 'Type', 'version' => 'Version'].
         *  'sort'              : A string containing the sorting column. Default value is 'title'.
         *
         * @return array Return an array containing the table data.
         */
        function get_prepared_table($posts, $args = [])
        {
            /* merge args with defaults */
            $args = array_merge([
                'columns' => ['permalink' => 'Title', 'type' => 'Type', 'version' => 'Version', 'id' => 'Post ID'],
                'sort' => 'title'
            ],
                $args);

            /* prepare table data */
            $tableData = [];

            /* get all column information */
            foreach ($posts as $post) {

                /* prepare key for sorting */
                // TODO @2.0 Roadmap : sort by something else than title
                switch ($args['sort']) {

                    case 'title' :
                        $tableDataID = strtolower(oes_get_display_title($post->ID));
                        break;

                    default:
                        $tableDataID = $post->ID;

                }

                /* modify ID if already stored (post with the same title exists) */
                while ($tableData[$tableDataID]) $tableDataID .= '0';

                /* loop through columns */
                foreach ($args['columns'] as $columnKey => $columnLabel) {
                    switch ($columnKey) {

                        case 'id' :
                            $tableData[$tableDataID]['id'] = $post->ID;
                            break;

                        case 'permalink' :
                            $tableData[$tableDataID]['permalink'] = sprintf('<a href="%1s">%2s</a>',
                                get_permalink($post->ID),
                                oes_get_display_title($post->ID));
                            break;

                        case 'type' :
                            $tableData[$tableDataID]['type'] = get_post_type_object(get_post_type($post->ID))->label;
                            break;

                        case 'version' :
                            $tableData[$tableDataID]['version'] = V\get_acf_version_field($post->ID);
                            break;

                        case 'custom' :
                            //TODO @2.0 Roadmap : add custom callback
                            break;
                    }
                }
            }

            /* sort array */
            ksort($tableData, SORT_STRING);

            /* return only data*/
            return $tableData;
        }


        /**
         * Modify prepared table representation of data with distinct posts depending on their master post. Group posts
         * with the same master post in one table row.
         *
         * @param array $posts An array containing posts.
         * @param array $args An array containing table parameter. Valid parameters are:
         *  'columns'           : An array containing the column headers. Default value is
         *                        ['permalink' => 'Title', 'type' => 'Type', 'version' => 'Version'].
         *  'sort'              : A string containing the sorting column. Default value is 'title'.
         *
         * @return array Return an array containing the table data.
         */
        function get_prepared_table_distinct($posts, $args = [])
        {

            /* get table data */
            $tableData = $this->get_prepared_table($posts, $args);

            /* modify table data (tableData already sorted by title) */
            $tableDataModified = [];
            foreach ($tableData as $row) {

                $rowData = [
                    'permalink' => $row['permalink'],
                    'type' => $row['type'],
                    'version' => sprintf('<a href="%1s">%2s</a>',
                        get_permalink($row['id']),
                        $row['version'])
                ];

                /* check if post is connected to master post */
                if (V\get_master_id($row['id'])) {

                    /* get master post */
                    $masterPost = V\get_master_post($row['id']);

                    if ($masterPost) {

                        /* check if post with same master post has been already added */
                        if ($tableDataModified[$masterPost->ID]) {

                            /* check if post has more recent version */
                            $highestVersionPostID = V\get_post_with_highest_version([$row['id'], $masterPost->ID], true)->ID;

                            /* get current data for post */
                            $newRowData = $tableDataModified[$masterPost->ID];

                            /* modify permalink */
                            if ($highestVersionPostID == $row['id']) $newRowData['permalink'] = $row['permalink'];

                            /* modify version */
                            $versionLink = sprintf('<a href="%1s">%2s%3s</a>',
                                get_permalink($row['id']),
                                $row['version'],
                                V\get_origin_version_id($row['id']) ? __(' (Translation)', 'oes') : '');
                            $newRowData['version'] = $tableDataModified[$masterPost->ID]['version'] . ', ' . $versionLink;

                            /* is highest version */
                            $tableDataModified[$masterPost->ID] = $newRowData;
                            continue;
                        } /* else store post with post ID of master post */
                        else {
                            $tableDataModified[$masterPost->ID] = $rowData;
                            continue;
                        }
                    }
                }

                /* else store post */
                $tableDataModified[$row['id']] = $rowData;
            }

            return $tableDataModified;
        }


        /**
         * Get html representation of tags.
         *
         * @param array|bool $taxonomies An array containing all considered taxonomies or false if all taxonomies are
         * to be considered.
         *
         * @return string Return the html representation of tags.
         */
        function get_html_topics($taxonomies = false)
        {

            /* if not defined, get all taxonomies connected to this post */
            if (!$taxonomies) {
                foreach (get_object_taxonomies($this->postType) as $singleTaxonomy) {
                    $taxonomies[$singleTaxonomy] = [];
                }
            }

            /* loop through taxonomies */
            $tagsString = '';
            foreach ($taxonomies as $key => $taxonomy) {

                /* prepare strings */
                $termsExists = false;
                $prepareTagsString = '';

                /* get terms */
                $taxonomyID = is_array($taxonomy) ? $key : $taxonomy;

                /* optional: add header */
                if(isset($taxonomy['label'] )){
                    if ($taxonomy['label'] != 'none' || is_bool($taxonomy['label'] || !is_array($taxonomy))) {
                        $prepareTagsString .= sprintf('<div class="content-table-header1">%1s</div>',
                            (is_bool($taxonomy['label']) || empty($taxonomy['label']) || !is_array($taxonomy)) ?
                                get_taxonomy($taxonomyID)->label : $taxonomy['label']
                        );
                    }
                }

                /* loop through tags */
                if(!empty(get_the_terms($this->postID, $taxonomyID))){
                    foreach (get_the_terms($this->postID, $taxonomyID) as $term) {

                        $termsExists = true;

                        if ($this->pdf) {
                            $prepareTagsString .=
                                sprintf('<span class="oes-badge">%1s </span><span class="cheat"></span><br>',
                                    $term->name);
                        } else {
                            $prepareTagsString .= sprintf('<a href="%1s"><span class="oes-badge"%2s>%3s</span></a>',
                                get_term_link($term->term_id),
                                $taxonomy['badge-id'] ? ' id="' . $taxonomy['badge-id'] . '"' : '',
                                $term->name
                            );
                        }
                    }
                }

                if ($termsExists) $tagsString .= $prepareTagsString;
            }

            return empty($tagsString) ? '' : sprintf('<div class="topics">%1s</div>', $tagsString);
        }


        /**
         * Get all other versions of an article.
         *
         * TODO @2.0 Roadmap : use versioning functions instead.
         *
         * @return array Return array with post ids.
         */
        function get_all_versions()
        {

            $returnVersions = [];

            /* check if master post exists */
            if ($this->masterID) {

                $otherVersionsValue = get_post_meta($this->masterID,
                    C\Post_Type::FIELD_VERSION_IDS);
                $otherVersionsIDs = $otherVersionsValue[0];

                /* get version number and permalink for versions */
                if (count($otherVersionsIDs) > 1) {

                    foreach ($otherVersionsIDs as $postID) {

                        /* skip if post is translation from an other post */
                        $translatedFromID = V\get_origin_version_id($postID);

                        /* exclude current post and translations */
                        if ($postID != $this->postID && !$translatedFromID) {
                            $returnVersions[] = [
                                'id' => $postID,
                                'version' => get_acf_field(C\Post_Type::ACF_FIELD_VERSION, $postID),
                                'permalink' => get_permalink($postID)
                            ];
                        }
                    }
                }
            }

            return $returnVersions;
        }


        /**
         * Generate a pdf file with post type content and style defined in pdf_style.
         *
         * @param array $args An array containing parameters passed to get_html_main.
         *
         * @throws MpdfException
         */
        function create_pdf($args = [])
        {
            /* set pdf variable */
            $this->pdf = true;

            /* require autoload */
            if (!file_exists(OES_DEMO_PATH . '/vendor/autoload.php')) {
                throw new Exception("MPDF library is missing in path: " . OES_DEMO_PATH);
            }
            require_once OES_DEMO_PATH . '/vendor/autoload.php';

            /* generate new pdf */
            $mpdf = new Mpdf();

            /* footer */
            $footer = $this->pdf_footer();
            $mpdf->SetHTMLFooter($footer);

            /* generate style */
            $style = $this->pdf_style();
            $mpdf->WriteHTML($style);

            /* generate header */
            $header = $this->pdf_header();
            $mpdf->WriteHTML($header);

            /* generate content */
            $html = '<body>' . $this->get_html_main($args) . '</body>';
            $mpdf->WriteHTML($html);

            $mpdf->Output();
        }


        /**
         * Prepare pdf header with image.
         *
         * TODO @2.0 Roadmap : validate header image
         *
         * @return string Return pdf header.
         */
        function pdf_header()
        {
            return sprintf(
                '<div class="pdf-header"><span><img src="%1s" id="header-home"></span><span class="title">%2s</span></div>',
                plugins_url(C\Admin::CUSTOM_OES_LOGO_PATH),
                $this->title
            );
        }


        /**
         * Prepare pdf css style.
         */
        function pdf_style()
        {
            return '';
        }


        /**
         * Prepare pdf footer with image.
         *
         * @return string Return pdf footer.
         */
        function pdf_footer()
        {
            return '';
        }

    }
}